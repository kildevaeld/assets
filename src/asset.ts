
import {IFile} from './interface';
import {EventEmitter} from 'events';
import * as Path from 'path';

export function observe(target, key: string, descriptor: PropertyDescriptor) {
    let oset = descriptor.set;
    
    descriptor.set = function (value) {
        let oldValue = this[key];
        oset.call(this, value);
        if (typeof this.trigger === 'function') {
            this.trigger('change:' + key, oldValue, value);
        }
    }
}

export interface AssetOptions {
    /**  Unique id for the asset. Should be generated by the metaStore */
    id?: string;
    /**  Arbitrary for the file. */
    name?: string;
    /** File name */
    filename?: string;
    /** path to file (without the filename and prefixed with '/') */
    path?: string;
    /** The mime file of the file */
    mime?: string;
    /** The size of the file in bytes*/
    size?: number;
    /** Creation date */
    ctime?: number;
    /** Modification date */
    mtime?: number;
    /** Meta data */
    meta?: {[key: string]: any };
    /** Hidden */
    hidden?: boolean;
}

export class Asset implements IFile {
    private _attributes: {[key:string]: any};
    
    set id (id: string) { this._attributes['id'] = id; }
    get id (): string { return this.get('id'); }
    
    @observe
    /** Name of the asset */
    get name(): string { return this.get('name');}
    set name(name:string) {  this._attributes['name'] = name; }
    
    @observe
    /** The file name of the asset */
    get filename(): string { return this.get('filename');}
    set filename(filename:string) {  this._attributes['filename'] = filename; }
    
    @observe
    /** The path of the asset */
    get path(): string { return this.get('path');}
    set path(path:string) {  this._attributes['path'] = path; }
    
    @observe
    get mime(): string { return this.get('mime');}
    set mime(mime:string) {  this._attributes['mime'] = mime; }
    
    @observe
    get size(): number { return this.get('size');}
    set size(size:number) {  this._attributes['size'] = size; }
    
    @observe
    get ctime(): number { return this.get('ctime'); }
    set ctime(time: number) { this._attributes['ctime'] = time; }
    
    @observe
    get mtime(): number { return this.get('mtime'); }
    set mtime(time: number) { this._attributes['mtime'] = time; }
    
    @observe
    get hidden(): boolean { return this.get('hidden'); }
    set hidden(hidden:boolean) { this._attributes['hidden'] = hidden; }
    
    get meta(): {[key: string]: any} {
        return this._attributes['meta'];
    }
    
    get fullPath (): string {
        return Path.join(this.path, this.filename);
    }
    
    get (key: string): any {
        return this._attributes[key];
    }
    
    setMeta(key: string, value: any) {
        this._attributes['meta'][key] = value;
        return this;
    }
    
    toJSON(): IFile {
        return <IFile>this._attributes
    }
    
    validdata (): boolean {
        return this.size != null && this.filename != null && this.path != "" && this.mime != null;
    } 
    
    constructor(file:AssetOptions={}) {
        this._attributes = file;   
        if (!this._attributes['meta']) this._attributes['meta'] = {};
        
        if (!file.ctime) file.ctime = new Date().getTime() / 1000;
        if (!file.mtime) file.mtime = file.ctime;
        
        if (file.hidden == null) file.hidden = false;
        
    }
}